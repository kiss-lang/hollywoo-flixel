(loadFrom "hollywoo" "src/hollywoo/HollywooDSL.kiss")

(defMacroVar subclass true)
(loadFrom "hollywoo" "src/hollywoo/Movie.kiss")
(loadFrom "hollywoo-flixel" "src/hollywoo_flixel/Aliases.kiss")

(method :Dynamic callPrivate [:Dynamic obj :String method &rest :Array<Dynamic> args]
    (Reflect.callMethod obj (Reflect.field obj method) args))

(method newFlxTextProp [:String key :String text :Int size :FlxColor color &opt :String font]
    (_addProp key (SpriteTools.textPlate text size 0 color FlxColor.TRANSPARENT null font)))

// TODO this should work, but I think when unquotes are used, or the macro has args, this doesn't macroexpand
// to get handled as a (commands ...) block for some reason in AsyncEmbeddedScript2
**(defMacro addFlxTextProp [text size color &opt font]
    `(commands
        (preload (newFlxTextProp (+ "FlxText: " ,text) ,text ,size ,color ,(or font `null)))
        (addProp (+ "FlxText: " ,text) (+ "FlxText: " ,text " position") cc)))

(method tween [:FlxTween tween]
    (callPrivate FlxTween.globalManager "remove" tween false)
    (tweens.push tween))
(method :TweenOptions tweenOpts [&opt :Void->Void cc]
    (object
        onComplete 
            ->:Void tween {
                            (tweens.remove tween)
                            (when cc (cc))
                        }))

(method &override :Void _showScene [:Scene scene :Appearance appearance :FlxCamera camera :Continuation cc]
    (super._showScene scene appearance camera
        (makeCC
            (whenLet [overlaidProps (dictGet overlaidPropsInScenes sceneKey)]
                (doFor =>sprite key overlaidProps
                    (overlayPropOnCurrentSet key (makeCC null))))
            (whenLet [tweenedPositions (dictGet tweenedPositionsOfSpritesInScenes sceneKey)]
                (doFor =>sprite point tweenedPositions
                    (set sprite.x point.x)
                    (set sprite.y point.y)))
            (cc))))

(method &override moveCharacter [actorName :Dynamic newPosition :StageFacing newFacing :Continuation cc]
    (whenLet [tweenedPositions (dictGet tweenedPositionsOfSpritesInScenes sceneKey)]
        (tweenedPositions.remove (dictGet actors actorName)))
    (super.moveCharacter actorName newPosition newFacing cc))

(method &override removeProp [name :Continuation cc]
    (let [prop (dictGet props name)]
        (whenLet [overlaidProps (dictGet overlaidPropsInScenes sceneKey)]
            (overlaidProps.remove prop)))
    (super.removeProp name cc))


@:keep
(method linearMotion [:Bool skipping :FlxSprite sprite :Float destX :Float destY :Float speed &opt :Void->Void cc :String soundLoop :Float volumeMod :Array<FlxSprite> connectedSprites]
    (unless (tweenedPositionsOfSpritesInScenes.exists sceneKey)
        (dictSet tweenedPositionsOfSpritesInScenes sceneKey (new Map)))
    (dictSet (dictGet tweenedPositionsOfSpritesInScenes sceneKey) sprite (FlxPoint.get destX destY))
    (when skipping
        (when cc (cc))
        (return))
    (when soundLoop
        (let [oldCC cc]
            (set cc
                (makeCC
                    (stopSound skipping soundLoop (makeCC null))
                    (when oldCC
                        (oldCC)))))
        (loopSound skipping soundLoop (makeCC null) volumeMod))
    (tween
        (FlxTween.linearMotion sprite sprite.x sprite.y destX destY speed false (tweenOpts cc)))
    (when connectedSprites
        (doFor cSprite connectedSprites
            (let [xOffset (- cSprite.x sprite.x)
                    yOffset (- cSprite.y sprite.y)]
                (linearMotion skipping cSprite (+ destX xOffset) (+ destY yOffset) speed)))))

@:keep
(method linearMotionTo [:Bool skipping :FlxSprite sprite :String positionKey :Float speed &opt :Void->Void cc :String soundLoop :Float volumeMod :Array<FlxSprite> connectedSprites]
    (let [position (resolvePosition positionKey)]
        (linearMotion skipping sprite position.x position.y speed cc soundLoop volumeMod connectedSprites)))

(defMacro _linearMotionTo [withMacro await objectKey positionKey speed soundLoop volumeMod]
    `(,withMacro ,objectKey o
        (linearMotionTo
            skipping
            o
            ,positionKey
            ,speed
            ,(if (eval await) `cc `null)
            ,soundLoop
            ,volumeMod)
        ,(if (eval await) `null `(cc))))

(defMacroFunction tryRead [stream]
    (try (read stream)
        (catch [e] `null)))

(defMacroFunction awaitLMTReaderMacro [stream withMacro await]
    (let [nextLineStream (stream.expect "hollywoo macro line" ->(stream.takeLineAsStream))
            exps [(read nextLineStream) (read nextLineStream) (read nextLineStream) (tryRead nextLineStream) (tryRead nextLineStream)]]
        `(_linearMotionTo ,withMacro ,await ,@exps)))

(defReaderMacro "AWAITLINEARMOTIONACTORTO" [stream &builder b]
    (awaitLMTReaderMacro stream `withActorCC true)) 

(defReaderMacro "AWAITLINEARMOTIONPROPTO" [stream &builder b]
    (awaitLMTReaderMacro stream `withPropCC true)) 

(defReaderMacro "LINEARMOTIONACTORTO" [stream &builder b]
    (awaitLMTReaderMacro stream `withActorCC false)) 

(defReaderMacro "LINEARMOTIONPROPTO" [stream &builder b]
    (awaitLMTReaderMacro stream `withPropCC false)) 


(defMacro _linearMotion [withMacro await objectKey _x _y speed soundLoop volumeMod]
    `(,withMacro ,objectKey o
        (let [x o.x y o.y]
            (linearMotion
                skipping
                o
                ,_x
                ,_y
                ,speed
                ,(if (eval await) `cc `null)
                ,soundLoop
                ,volumeMod))
        ,(if (eval await) `null `(cc))))

(defMacroFunction awaitLMReaderMacro [stream withMacro await]
    (let [nextLineStream (stream.expect "hollywoo macro line" ->(stream.takeLineAsStream))
            exps [(read nextLineStream) (read nextLineStream) (read nextLineStream) (read nextLineStream) (tryRead nextLineStream) (tryRead nextLineStream)]]
        `(_linearMotion ,withMacro ,await ,@exps)))

(defReaderMacro "AWAITLINEARMOTIONACTOR" [stream &builder b]
    (awaitLMReaderMacro stream `withActorCC true)) 

(defReaderMacro "AWAITLINEARMOTIONPROP" [stream &builder b]
    (awaitLMReaderMacro stream `withPropCC true)) 

(defReaderMacro "LINEARMOTIONACTOR" [stream &builder b]
    (awaitLMReaderMacro stream `withActorCC false)) 

(defReaderMacro "LINEARMOTIONPROP" [stream &builder b]
    (awaitLMReaderMacro stream `withPropCC false)) 

(defReaderMacro "ACTORPLAYANIMATION" [stream &builder b]
    (let [actor (read stream)
            anim (read stream)]
        `(withActor ,actor a (a.playAnimation ,anim))))


// Reusable effect: Scan a slightly transparent line side-to-side across a FlxSprite like a scanner
@:keep
(method :Void scanLineEffect [:Bool skipping :FlxSprite sprite :FlxColor lineColor :Int lineThickness :Float alpha :Bool vertical :Float speed &opt :Bool repeat :Void->Void cc :String soundLoop :Float volumeMod]
    (when skipping
        (cc)
        (return))
    (unless repeat (set repeat true))
    (let [lineSprite (new FlxSprite)
            width (if vertical lineThickness (Std.int sprite.width))
            height (if vertical (Std.int sprite.height) lineThickness)
            lineStartX sprite.x
            lineStartY sprite.y
            lineEndX (if vertical
                            (+ sprite.x sprite.width (- lineThickness))
                        sprite.x)
            lineEndY (if vertical
                            sprite.y
                        (+ sprite.y sprite.height (- lineThickness)))
            finish ->:Void {
                        (FlxG.state.remove lineSprite true)
                        (cc)
            }]
        (lineSprite.makeGraphic width height lineColor)
        (set lineSprite.cameras sprite.cameras)
        (set lineSprite.alpha alpha)
        
        (set lineSprite.x lineStartX)
        (set lineSprite.y lineStartY)
        (FlxG.state.add lineSprite)
        (linearMotion skipping lineSprite lineEndX lineEndY speed
            ->:Void {
                (if repeat
                        (linearMotion skipping lineSprite lineStartX lineStartY speed finish soundLoop volumeMod) 
                    (finish))
            }
            soundLoop volumeMod)))

(method :Void rotateTo [:Bool skipping :FlxSprite sprite :Float angle :Float duration &opt :Void->Void cc :String soundLoop :Float volumeMod]
    (when skipping
        (cc)
        (return))
    (when soundLoop
        (let [oldCC cc]
            (set cc
                (makeCC
                    (stopSound skipping soundLoop (makeCC null))
                    (when oldCC
                        (oldCC)))))
        (loopSound skipping soundLoop (makeCC null) volumeMod))
    (tween
        (FlxTween.angle sprite sprite.angle angle duration (tweenOpts cc))))

(defMacro newFlxSet [name assetPath]
    `(loadSet ,name ,assetPath))

(defMacro newBlankFlxSet [name color]
    `(let [setSprite (new FlxSprite 0 0)]
        // make graphic uniquely so we can draw on sets for specific scenes
        (setSprite.makeGraphic FlxG.width FlxG.height ,color true)
        (addSet ,name setSprite)))

(defMacro newFlxSound [name path description]
    `(loadSound ,name ,path ,description))


(defMacro newFlxSong [name path]
    `(loadSong ,name ,path))

(defMacro newFlxVoiceTrack [name wavPath jsonPath]
    `(_loadVoiceTrack ,name ,wavPath (openfl.utils.Assets.getText ,jsonPath)))

(method newFlxVoiceTracks [:Array<String> names :Array<String> wavJsonPaths]
    (doFor name names
        (doFor [wavPath jsonPath] (groups wavJsonPaths 2 Throw)
            (newFlxVoiceTrack name wavPath jsonPath))))

(#when sys
    (method newFlxVoiceTracksByPrefix [:Array<String> names :String voFolder :String voFilePrefix]
        (let [possibleFiles (sys.FileSystem.readDirectory voFolder)
                matchingWavFiles (filter possibleFiles ->[:String path] (and (StringTools.startsWith path voFilePrefix) (StringTools.endsWith path ".wav")))]
            (doFor name names
                (doFor wavPath matchingWavFiles
                    (let [wavPath (joinPath voFolder wavPath)]
                        (newFlxVoiceTrack name wavPath (StringTools.replace wavPath ".wav" ".json"))))))))

(defMacro newFlxProp [name path]
    `(loadProp ,name ,path))

(method prepNewFlxProp [name path &opt :FlxSprite->Void prepareSprite]
    (let [propSprite (new FlxSprite 0 0)]
        (propSprite.loadGraphic path false 0 0 true) // Load props uniquely because they can be drawn on
        (when prepareSprite
            (prepareSprite propSprite))
        (_addProp name propSprite)))

(function flxSprite [:String asset]
    (new FlxSprite 0 0 asset))

(var FAST_FORWARD_MOD 3)

(defAlias &ident flxDirector (cast director FlxDirector))

(method &override :Void update [:Float elapsed]
    (when skipMovie
        (skipMovie.update elapsed)
        (return))

    (doFor action nextFrameActions
        (action))
    (set nextFrameActions [])
    (unless paused
        (let [tweenElapsed (* elapsed (if flxDirector.fastForwardAction.triggered FAST_FORWARD_MOD 1))]
            (doFor tween tweens
                (callPrivate tween "update" tweenElapsed)
                (when tween.finished
                    (callPrivate tween "finish"))))
        (when inCamera
            (set inCamera.x inCameraPos.x)
            (set inCamera.y inCameraPos.y)
            (set outCamera.x outCameraPos.x)
            (set outCamera.y outCameraPos.y)))
    (.update (cast (director.shortcutHandler) kiss_flixel.FlxKeyShortcutHandler<Dynamic>)))

(prop &mut :FlxSprite _canvas null)
(method :FlxSprite canvas []
    (unless (= _canvas?.width FlxG.width)
        (set _canvas (new FlxSprite 0 0))
        (_canvas.makeGraphic FlxG.width FlxG.height FlxColor.BLACK))
    _canvas)

(method :StagePosition FullControl [:FlxSprite s :Int layer :RelativePosition rpos &opt :Bool isProp]
    (assert (<= 0 layer FlxDirector.LAYER_MAX) "Layer $layer is out of range 0-$FlxDirector.LAYER_MAX")
    (when isProp
        (flxDirector.scaleProp s))
    (let [[x y] (SpriteTools.positionOn s (canvas) rpos true)]
        (new StagePosition x y layer)))

(method namePlates [:Bool skipping :Array<String> names :Dynamic delayLength :Bool delayWhileShown :Void->Void cc]
    (when skipping
        (cc)
        (return))
    (let [plates
                (for name names
                    (let [plate (SpriteTools.textPlate name FlxDirector.DIALOG_SIZE FlxDirector.SUPER_MARGIN)
                            actor .actor (dictGet .characters (_currentScene) name)]
                        (set plate.x (- (+ actor.x (/ actor.width 2))
                                        (/ plate.width 2)))
                        (set plate.y (+ actor.y actor.height))
                        (FlxG.state.add plate)
                        plate))]
        (delay skipping delayLength 
            (makeCC
                (doFor plate plates (FlxG.state.remove plate true))
                (when delayWhileShown (cc)))))
    (unless delayWhileShown (cc)))

(method putPresetPosition [key x y z]
    (let [pos (new StagePosition (Std.int x) (Std.int y) (Std.int z))]
        (stagePositions.put key pos)
        (dictSet presetPositions (pos.stringify) true)))

(method &override :Void createCameras []
    (unless uiCamera
        (set uiCamera (new flixel.FlxCamera))
        (set uiCamera.bgColor FlxColor.TRANSPARENT)
        (flixel.FlxG.cameras.add uiCamera)
        (set kiss_flixel.SimpleWindow.defaultCamera uiCamera))
    (unless screenCamera
        (set screenCamera (new flixel.FlxCamera))
        (set screenCamera.bgColor FlxColor.TRANSPARENT)
        (FlxG.cameras.add screenCamera)))

(preload
    (.enableGamepadInput
        (cast (director.shortcutHandler) kiss_flixel.FlxKeyShortcutHandler<Dynamic>)
        [
            =>flixel.input.gamepad.FlxGamepadInputID.START "escape"
            =>flixel.input.gamepad.FlxGamepadInputID.X "tab"
        ])
    (set FlxDirector.anonProps 0)
    (set FlxG.sound.volume FlxDirector.masterVolume)
    (createCameras)
    
    // These are set here so they're defined after FlxG.width and height have been set:
    (set STAGE_LEFT_X 150.0)
    (set STAGE_RIGHT_X (- FlxG.width STAGE_LEFT_X))
    (set ACTOR_Y (- FlxG.height 220.0))
    (set ACTOR_WIDTH 300)
    (set STAGE_BEHIND_DY 250.0)
    (set DIALOG_X ACTOR_WIDTH)
    (set DIALOG_Y (- FlxG.height 220.0))
    (set DIALOG_WIDTH (Std.int (- FlxG.width ACTOR_WIDTH ACTOR_WIDTH)))
    (set DIALOG_HEIGHT (Std.int (- FlxG.height DIALOG_Y)))
    
    (putPresetPosition "Left" STAGE_LEFT_X ACTOR_Y 0.0)
    (putPresetPosition "Right" STAGE_RIGHT_X ACTOR_Y 0.0)
    (putPresetPosition "Left2" STAGE_LEFT_X ACTOR_Y STAGE_BEHIND_DY)
    (putPresetPosition "Right2" STAGE_RIGHT_X ACTOR_Y STAGE_BEHIND_DY)
    (putPresetPosition "Left3" STAGE_LEFT_X ACTOR_Y (* 2 STAGE_BEHIND_DY))
    (putPresetPosition "Right3" STAGE_RIGHT_X ACTOR_Y (* 2 STAGE_BEHIND_DY))

    (putPresetPosition "OffScreenLeft" (- (fHalf ACTOR_WIDTH)) ACTOR_Y 0.0)
    (putPresetPosition "OffScreenRight" (+ FlxG.width (fHalf ACTOR_WIDTH)) ACTOR_Y 0.0)
    (putPresetPosition "OffScreenLeft2" (- (fHalf ACTOR_WIDTH)) ACTOR_Y STAGE_BEHIND_DY)
    (putPresetPosition "OffScreenRight2" (+ FlxG.width (fHalf ACTOR_WIDTH)) ACTOR_Y STAGE_BEHIND_DY)

    (let [left (/ FlxG.width 6)
            right (- FlxG.width left)
            upper (/ FlxG.height 6)
            lower (- FlxG.height upper)
            centerX (/ FlxG.width 2)
            centerY (/ FlxG.height 2)
            layer 5]
        (putPresetPosition "ScreenCenter" centerX centerY layer)
        (putPresetPosition "ScreenCenterLeft" left centerY layer)
        (putPresetPosition "ScreenCenterRight" right centerY layer)
        (putPresetPosition "ScreenUpperLeft" left upper layer)
        (putPresetPosition "ScreenUpperRight" right upper layer)
        (putPresetPosition "ScreenLowerLeft" left lower layer)
        (putPresetPosition "ScreenLowerRight" right lower layer)
        (putPresetPosition "ScreenLowerCenter" centerX lower layer)
        (putPresetPosition "ScreenUpperCenter" centerX upper layer))
        
    // Prepare the interpreter for this movie's cached instructions
	(let [v interpVariables]
		(dictSet v "SpriteTools" kiss_flixel.SpriteTools)
        (let [colors FlxColor.colorLookup
                colorObject (object)
                utilObject (object)
                flixelObject (object)]
            (doFor =>key color colors
                (Reflect.setField colorObject key color))
            // All of these Reflect.setFields are to work around kiss bug #196
            (Reflect.setField utilObject "FlxColor" colorObject)
            (Reflect.setField flixelObject "util" utilObject)
            (Reflect.setField flixelObject "FlxG" FlxG)
            (dictSet v "flixel" flixelObject))
        
        (dictSet v "FlxG" FlxG)
        (dictSet v "Pixels" kiss_flixel.RelativeCoordinate.Pixels)
        (dictSet v "Percent" kiss_flixel.RelativeCoordinate.Percent)
        )
        
    (let [shortcutHandler (director.shortcutHandler)
            cc ->(resume)]    
        (shortcutHandler.registerItem "[d]efine prop [s]cale"
            ->cc
                (director.chooseString "Which prop?" (dictGet propsInScene sceneKey)
                    ->propKey
                        (let [lastScale .value (propScales.get propKey)]
                            (director.enterString "Redefine $propKey scale from ${lastScale}?" 
                                ->scaleStr
                                    (let [scale (Std.parseFloat scaleStr)]
                                        (propScales.put propKey (new HFloat scale))
                                        // Re-scale props immediately
                                        (doFor prop .props (dictGet scenes sceneKey)
                                            (flxDirector.scaleProp prop.prop))
                                        (cc))))))
        (shortcutHandler.registerItem "[d]efine [z] of a position"
            ->cc
                (director.chooseString "Which position?" (dictGet positionsInScene sceneKey)
                    ->positionKey
                        (let [position (stagePositions.get positionKey)]
                            (director.enterString "Redefine z from ${position.z}?"
                                ->zStr {
                                    (stagePositions.put positionKey (new StagePosition position.x position.y (Std.parseFloat zStr)))
                                    (cc)
                                }))))))

(method overlayPropOnCurrentSet [propKey :Void->Void cc]
    (let [propKey (kiss.FuzzyMapTools.bestMatch props propKey)]
        (dictSet shownProps propKey true) // Don't scale when showing
        (withProp propKey p
            (unless (overlaidPropsInScenes.exists sceneKey)
                (dictSet overlaidPropsInScenes sceneKey (new Map)))
            (dictSet (dictGet overlaidPropsInScenes sceneKey) p propKey)
            (withSceneSetCC sceneKey bg
                (addProp propKey (new StagePosition bg.x bg.y 1) cc)
                (p.setGraphicSize (Std.int bg.width) (Std.int bg.height))
                (p.updateHitbox)))))

(method loadSkySprite [time path &opt :Void->Void cc]
    (dictSet flxDirector.skySprites time (.loadGraphic (new FlxSprite) path))
    (when cc (cc)))

(defMacro logSprites []
    `{(kiss_flixel.SpriteTools.logSprites)(cc)})

(prop &mut :FlxSprite inCameraPos)
(prop &mut :FlxCamera inCamera)
(prop &mut :FlxSprite outCameraPos)
(prop &mut :FlxCamera outCamera)
(method :Void tweenScene [:Bool skipping name :Float speed :Continuation cc &opt :Bool fromLeft :String soundLoop :Float volumeMod]
    (when skipping
        (setScene name cc)
        (return))
    (let [name (kiss.FuzzyMapTools.bestMatch scenes name)
            lastSceneKey sceneKey
            lastScene (dictGet scenes sceneKey)
            scene (dictGet scenes name)
            camera scene.camera
            finish (makeCC
                        // Needs to be done 1 more time:
                        (set inCamera.x inCameraPos.x)
                        (set outCamera.x outCameraPos.x)

                        (set inCamera null)
                        (set outCamera null)
                        (set sceneKey lastSceneKey)
                        (_hideCurrentScene
                            (makeCC
                                (set sceneKey name)
                                (cc))))]
        
        (unless (positionsInScene.exists name)
            (dictSet positionsInScene name []))
        
        (set inCamera camera)
        (set inCameraPos (new FlxSprite
                                (if ?fromLeft
                                        -FlxG.width
                                    FlxG.width)
                                0))
        (set inCamera.x inCameraPos.x)

        (set outCamera lastScene.camera)
        (set outCameraPos (new FlxSprite outCamera.x outCamera.y))
        (set sceneKey name)
        (_showScene
            scene
            (hollywoo.Movie.appearanceFlag shownScenes name)
            camera
            (makeCC
                (linearMotion skipping inCameraPos 0 0 speed finish soundLoop volumeMod [outCameraPos])))))


(function destroyAndClear [:kiss.FuzzyMap<Dynamic> m]
    (doFor =>key thing m
        (thing.destroy))
    (m.clear))

(defMacro addSkips [flxMovieClass]
    `{
        (method &override :Void prepareForSkip []
            // TODO these things could/should all be in HollywooDSL:
            (kiss_tools.TimerWithPause.stopAll)
            (flxDirector.pause)
            (.clear (director.shortcutHandler))
            (set skipMovie (new ,flxMovieClass flxDirector))
            (skipMovie.scavengeObjects this)
            (doCleanup))

        (preload
            (unless (FlxG.inputs.list.contains flxDirector.actionManager)
                (FlxG.inputs.add flxDirector.actionManager))

            (set onLabel ->:Void label (FlxDirector.lastSceneForMovie this label)))

        (cleanup
            (when skipMovie?.running
                (callPrivate skipMovie "doCleanup")))

        (cleanup
            (set tweens [])
            (set flxDirector.nextCC null)
            (loopingSoundPlays.clear)
            (destroyAndClear actors)
            (destroyAndClear props)
            (destroyAndClear sets)
            (destroyAndClear sounds)
            (destroyAndClear voiceTracks)
            (destroyAndClear songs)

            // I hope this disposes of references to actors, props, sets, etc.:
            (scenes.clear)

            (propScales.m.clear)
            (propsInScene.clear)
            (overlaidPropsInScenes.clear)
            (doFor m tweenedPositionsOfSpritesInScenes
                (doFor p m
                    (p.put))
                (m.clear))
            (tweenedPositionsOfSpritesInScenes.clear)

            (doFor =>key lightSourceList lightSources
                (whileLet [lightSource (lightSourceList.elements.pop)]
                    (lightSource.destroy)))

            (#when cpp
                (cpp.vm.Gc.run true)
                (cpp.vm.Gc.compact)))

        (#when debug
            (preload
                (.registerItem (director.shortcutHandler) "[n]ext label"
                                ->cc {
                                    (prepareForSkip)
                                    (runFromNextLabel skipMovie)
                                })       


                (.registerItem (director.shortcutHandler) "skip to [l]abel"
                                ->cc
                                    (flxDirector.sceneSelection ->:Void {}))))
    })