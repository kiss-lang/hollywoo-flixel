(loadFrom "hollywoo" "src/hollywoo/HollywooDSL.kiss")

(defMacroVar subclass true)
(loadFrom "hollywoo" "src/hollywoo/Movie.kiss")
(loadFrom "hollywoo-flixel" "src/hollywoo_flixel/Aliases.kiss")

(method :Dynamic callPrivate [:Dynamic obj :String method &rest :Array<Dynamic> args]
    (Reflect.callMethod obj (Reflect.field obj method) args))

(method tween [:FlxTween tween]
    (callPrivate FlxTween.globalManager "remove" tween false)
    (tweens.push tween))
(method :TweenOptions tweenOpts [&opt :Void->Void cc]
    (object
        onComplete 
            ->:Void tween {
                            (tweens.remove tween)
                            (when cc (cc))
                        }))

(method linearMotion [:FlxSprite sprite :Float destX :Float destY :Float speed &opt :Void->Void cc :String soundLoop :Float volumeMod :Array<FlxSprite> connectedSprites]
    (when soundLoop
        (let [oldCC cc]
            (set cc
                (makeCC
                    (stopSound soundLoop (makeCC null))
                    (when oldCC
                        (oldCC)))))
        (loopSound soundLoop (makeCC null) volumeMod))
    (tween
        (FlxTween.linearMotion sprite sprite.x sprite.y destX destY speed false (tweenOpts cc)))
    (when connectedSprites
        (doFor cSprite connectedSprites
            (let [xOffset (- cSprite.x sprite.x)
                    yOffset (- cSprite.y sprite.y)]
                (linearMotion cSprite (+ destX xOffset) (+ destY yOffset) speed)))))
(defAlias &ident FlxTween.linearMotion CHANGE_TO_MOVIE_LINEARMOTION)

(method linearMotionTo [:FlxSprite sprite :String positionKey :Float speed &opt :Void->Void cc :String soundLoop :Float volumeMod :Array<FlxSprite> connectedSprites]
    (let [position (resolvePosition positionKey)]
        (linearMotion sprite position.x position.y speed cc soundLoop volumeMod connectedSprites)))

(method rotateTo [:FlxSprite sprite :Float angle :Float duration &opt :Void->Void cc :String soundLoop :Float volumeMod]
    (when soundLoop
        (let [oldCC cc]
            (set cc
                (makeCC
                    (stopSound soundLoop (makeCC null))
                    (when oldCC
                        (oldCC)))))
        (loopSound soundLoop (makeCC null) volumeMod))
    (tween
        (FlxTween.angle sprite sprite.angle angle duration (tweenOpts cc))))

(method newFlxSet [name assetPath]
    (let [setSprite (new FlxSprite 0 0)]
        (setSprite.loadGraphic assetPath false 0 0 true) // Load uniquely so we can draw on sets for specific scenes
        (newSet name setSprite)))

(method newBlankFlxSet [name :FlxColor color]
    (let [setSprite (new FlxSprite 0 0)]
        (setSprite.makeGraphic FlxG.width FlxG.height color true) // Load uniquely so we can draw on sets for specific scenes
        (newSet name setSprite)))

(method newFlxSound [name path &opt :Float volume]
    (set volume (or volume 1))
    (assert (<= 0 volume 1))
    (let [s (FlxG.sound.load path)]
        (set s.volume volume)
        (set s.persist true)
        (newSound name s)))

(method newFlxSong [name path]
    (newSong name path))

(method newFlxVoiceTrack [name wavPath jsonPath]
    (newVoiceTrack name (FlxG.sound.load wavPath) (openfl.utils.Assets.getText jsonPath)))

(method newFlxVoiceTracks [:Array<String> names :Array<String> wavJsonPaths]
    (doFor name names
        (doFor [wavPath jsonPath] (groups wavJsonPaths 2 Throw)
            (newFlxVoiceTrack name wavPath jsonPath))))

(method newFlxProp [name path &opt :FlxSprite->Void prepareSprite]
    (let [propSprite (new FlxSprite 0 0)]
        (propSprite.loadGraphic path false 0 0 true) // Load props uniquely because they can be drawn on
        (when prepareSprite
            (prepareSprite propSprite))
        (newProp name propSprite)))

(function flxSprite [:String asset]
    (new FlxSprite 0 0 asset))

(method :Void update [:Float elapsed]
    (doFor action nextFrameActions
        (action))
    (set nextFrameActions [])
    (unless paused
        (doFor tween tweens
            (callPrivate tween "update" elapsed)
            (when tween.finished
                (callPrivate tween "finish"))))
    (.update (cast (director.shortcutHandler) kiss_tools.FlxKeyShortcutHandler<Dynamic>)))

(defAlias &ident flxDirector (cast director FlxDirector))

(prop &mut :FlxSprite _canvas null)
(method :FlxSprite canvas []
    (unless (= _canvas?.width FlxG.width)
        (set _canvas (new FlxSprite 0 0))
        (_canvas.makeGraphic FlxG.width FlxG.height FlxColor.BLACK))
    _canvas)

(method namePlates [:Array<String> names :Dynamic delayLength :Bool delayWhileShown :Void->Void cc]
    (let [plates
                (for name names
                    (let [plate (SpriteTools.textPlate name FlxDirector.DIALOG_SIZE FlxDirector.SUPER_MARGIN)
                            actor .actor (dictGet .characters (_currentScene) name)]
                        (set plate.x (- (+ actor.x (/ actor.width 2))
                                        (/ plate.width 2)))
                        (set plate.y (+ actor.y actor.height))
                        (FlxG.state.add plate)
                        plate))]
        (delay delayLength 
            (makeCC
                (doFor plate plates (FlxG.state.remove plate true))
                (when delayWhileShown (cc)))))
    (unless delayWhileShown (cc)))

(method loopSound [name :Void->Void cc &opt :Float volumeMod]
    (playSound name (makeCC null) volumeMod false)
    (let [cs flxDirector.currentSounds
            sound (nth cs (- cs.length 1))
            onComplete sound.onComplete]
        (dictSet loopingOnCompletes sound onComplete)
        (set sound.onComplete null)
        (set sound.looped true))
    (cc))

(method putPresetPosition [key x y z]
        (let [pos (new StagePosition (Std.int x) (Std.int y) (Std.int z))]
            (stagePositions.put key pos)
            (dictSet presetPositions (pos.stringify) true)))

(preload
    (unless uiCamera
        (set uiCamera (new flixel.FlxCamera))
        (set uiCamera.bgColor FlxColor.TRANSPARENT)
        (flixel.FlxG.cameras.add uiCamera)
        (set kiss_flixel.SimpleWindow.defaultCamera uiCamera))
    (unless screenCamera
        (set screenCamera (new flixel.FlxCamera))
        (set screenCamera.bgColor FlxColor.TRANSPARENT)
        (FlxG.cameras.add screenCamera))
    // These are set here so they're defined after FlxG.width and height have been set:
    (set STAGE_LEFT_X 150.0)
    (set STAGE_RIGHT_X (- FlxG.width STAGE_LEFT_X))
    (set ACTOR_Y (- FlxG.height 220.0))
    (set ACTOR_WIDTH 300)
    (set STAGE_BEHIND_DY 250.0)
    (set DIALOG_X ACTOR_WIDTH)
    (set DIALOG_Y (- FlxG.height 220.0))
    (set DIALOG_WIDTH (Std.int (- FlxG.width ACTOR_WIDTH ACTOR_WIDTH)))
    (set DIALOG_HEIGHT (Std.int (- FlxG.height DIALOG_Y)))
    
    (putPresetPosition "Left" STAGE_LEFT_X ACTOR_Y 0.0)
    (putPresetPosition "Right" STAGE_RIGHT_X ACTOR_Y 0.0)
    (putPresetPosition "Left2" STAGE_LEFT_X ACTOR_Y STAGE_BEHIND_DY)
    (putPresetPosition "Right2" STAGE_RIGHT_X ACTOR_Y STAGE_BEHIND_DY)
    (let [left (/ FlxG.width 6)
            right (- FlxG.width left)
            upper (/ FlxG.height 6)
            lower (- FlxG.height upper)
            centerX (/ FlxG.width 2)
            centerY (/ FlxG.height 2)
            layer 5]
        (putPresetPosition "ScreenCenter" centerX centerY layer)
        (putPresetPosition "ScreenUpperLeft" left upper layer)
        (putPresetPosition "ScreenUpperRight" right upper layer)
        (putPresetPosition "ScreenLowerLeft" left lower layer)
        (putPresetPosition "ScreenLowerRight" right lower layer)
        (putPresetPosition "ScreenLowerCenter" centerX lower layer)
        (putPresetPosition "ScreenUpperCenter" centerX upper layer))
        
    (let [shortcutHandler (director.shortcutHandler)
            cc ->(resume)]    
        (shortcutHandler.registerItem "[d]efine prop [s]cale"
            ->cc
                (director.chooseString "Which prop?" (dictGet propsInScene sceneKey)
                    ->propKey
                        (let [lastScale .value (propScales.get propKey)]
                            (director.enterString "Redefine $propKey scale from ${lastScale}?" 
                                ->scaleStr
                                    (let [scale (Std.parseFloat scaleStr)]
                                        (propScales.put propKey (new HFloat scale))
                                        (cc))))))))

(method overlayPropOnCurrentSet [propKey :Void->Void cc]
    (let [propKey (kiss.FuzzyMapTools.bestMatch props propKey)]
        (dictSet shownProps propKey true) // Don't scale when showing
        (withProp propKey p
            (withSceneSetCC sceneKey bg
                (p.setGraphicSize (Std.int bg.width) (Std.int bg.height))
                (p.updateHitbox)
                (addProp propKey (new StagePosition bg.x bg.y 1) cc)))))

(method loadSkySprite [time path &opt :Void->Void cc]
    (dictSet flxDirector.skySprites time (.loadGraphic (new FlxSprite) path))
    (when cc (cc)))

(defMacro logSprites []
    `{(kiss_flixel.SpriteTools.logSprites)(cc)})